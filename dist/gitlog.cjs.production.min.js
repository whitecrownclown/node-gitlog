"use strict";
Object.defineProperty(exports, "__esModule", { value: !0 });
var e,
  t = require("child_process"),
  r = require("fs");
function n() {
  return (n =
    Object.assign ||
    function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var r = arguments[t];
        for (var n in r)
          Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
      }
      return e;
    }).apply(this, arguments);
}
var i = ((e = require("debug")) && "object" == typeof e && "default" in e
    ? e.default
    : e)("gitlog"),
  a = {
    hash: "%H",
    abbrevHash: "%h",
    treeHash: "%T",
    abbrevTreeHash: "%t",
    parentHashes: "%P",
    abbrevParentHashes: "%P",
    authorName: "%an",
    authorEmail: "%ae",
    authorDate: "%ai",
    authorDateRel: "%ar",
    committerName: "%cn",
    committerEmail: "%ce",
    committerDate: "%cd",
    committerDateRel: "%cr",
    subject: "%s",
    body: "%b",
    rawBody: "%B",
    tags: "%D",
  },
  o = ["status", "files"],
  s = {
    number: 10,
    fields: ["abbrevHash", "hash", "subject", "authorName", "authorDate"],
    nameStatus: !0,
    includeMergeCommitFiles: !1,
    findCopiesHarder: !1,
    all: !1,
  },
  u = function (e, t, r) {
    return e.map(function (e) {
      var n = e.split("@end@"),
        a = n[0].split("\t");
      if (n[1]) {
        var s = n[1].trimLeft().split("\n");
        "" === s[s.length - 1] && s.pop(),
          s
            .map(function (e) {
              return e.split("\t");
            })
            .forEach(function (e) {
              for (
                var t = e[0], r = [t, e[e.length - 1]], n = 1, i = e.length - 1;
                n < i;
                n++
              )
                "R" === t.slice(0, 1) && r.push("D", e[n]);
              a.push.apply(a, r);
            });
      }
      i("commit", a), a.shift();
      var u = {};
      return (
        r &&
          o.forEach(function (e) {
            u[e] = [];
          }),
        a.forEach(function (e, n) {
          if (t[n])
            if ("tags" === t[n]) {
              var a = [],
                s = e.indexOf("tag: ");
              s >= 0 &&
                e
                  .substr(s + 5)
                  .trim()
                  .split(",")
                  .forEach(function (e) {
                    a.push(e.trim());
                  }),
                (u[t[n]] = a);
            } else u[t[n]] = e;
          else if (r) {
            var c = (n - t.length) % o.length;
            i("nameStatus", n - t.length, o.length, c, e);
            var f = u[o[c]];
            Array.isArray(f) && f.push(e);
          }
        }),
        u
      );
    });
  };
function c(e, c) {
  if (!e.repo) throw new Error("Repo required!");
  if (!r.existsSync(e.repo)) throw new Error("Repo location does not exist");
  var f = n({}, s, {}, e),
    l = n({ cwd: e.repo }, e.execOptions),
    h = (function (e) {
      var t = "git log ";
      return (
        e.findCopiesHarder && (t += "--find-copies-harder "),
        e.all && (t += "--all "),
        e.includeMergeCommitFiles && (t += "-m "),
        (t = (function (e, t) {
          for (
            var r = e,
              n = ["author", "since", "after", "until", "before", "committer"],
              i = n.length;
            i--;

          )
            t[n[i]] && (r += " --" + n[i] + '="' + t[n[i]] + '"');
          return r;
        })((t += "-n " + e.number), e)),
        (t += ' --pretty="@begin@'),
        e.fields &&
          e.fields.forEach(function (e) {
            if (!a[e] && !o.includes(e)) throw new Error("Unknown field: " + e);
            t += "\t" + a[e];
          }),
        (t += '@end@"'),
        e.branch && (t += " " + e.branch),
        e.nameStatus && (t += " --name-status"),
        e.file && (t += " -- " + e.file),
        i("command", e.execOptions, t),
        t
      );
    })(f);
  if (!c) {
    var m = t.execSync(h, l).toString().split("@begin@");
    return (
      "" === m[0] && m.shift(), i("commits", m), u(m, f.fields, f.nameStatus)
    );
  }
  t.exec(h, l, function (e, t, r) {
    i("stdout", t);
    var n = t.split("@begin@");
    "" === n[0] && n.shift(),
      i("commits", n),
      c(r || e, u(n, f.fields, f.nameStatus));
  });
}
(exports.default = c),
  (exports.gitlogPromise = function (e) {
    return new Promise(function (t, r) {
      c(e, function (e, n) {
        e ? r(e) : t(n);
      });
    });
  });
//# sourceMappingURL=gitlog.cjs.production.min.js.map
